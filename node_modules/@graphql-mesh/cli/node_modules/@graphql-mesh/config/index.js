'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const crossHelpers = require('@graphql-mesh/cross-helpers');
const graphql = require('graphql');
const utils = require('@graphql-tools/utils');
const paramCase = require('param-case');
const load = require('@graphql-tools/load');
const graphqlFileLoader = require('@graphql-tools/graphql-file-loader');
const utils$1 = require('@graphql-mesh/utils');
const codeFileLoader = require('@graphql-tools/code-file-loader');
const store = require('@graphql-mesh/store');
const pascalCase = require('pascal-case');
const camelCase = require('camel-case');
const core = require('@envelop/core');

async function getPackage({ name, type, importFn, cwd, additionalPrefixes = [], }) {
    const casedName = paramCase.paramCase(name);
    const casedType = paramCase.paramCase(type);
    const prefixes = ['@graphql-mesh/', ...additionalPrefixes];
    const initialPossibleNames = [casedName, `${casedName}-${casedType}`, `${casedType}-${casedName}`, casedType];
    const possibleNames = [];
    for (const prefix of prefixes) {
        for (const possibleName of initialPossibleNames) {
            possibleNames.push(`${prefix}${possibleName}`);
        }
    }
    for (const possibleName of initialPossibleNames) {
        possibleNames.push(possibleName);
    }
    if (name.includes('-')) {
        possibleNames.push(name);
    }
    const possibleModules = possibleNames.concat(crossHelpers.path.resolve(cwd, name));
    for (const moduleName of possibleModules) {
        try {
            const exported = await importFn(moduleName, true);
            const resolved = exported.default || exported;
            return {
                moduleName,
                resolved,
            };
        }
        catch (err) {
            const error = err;
            if (!error.message.includes(`Cannot find module '${moduleName}'`) &&
                !error.message.includes(`Cannot find package '${moduleName}'`) &&
                !error.message.includes(`Could not locate module`)) {
                throw new Error(`Unable to load ${type} matching ${name}: ${error.message}`);
            }
        }
    }
    throw new Error(`Unable to find ${type} matching ${name}`);
}
async function resolveAdditionalTypeDefs(baseDir, additionalTypeDefs) {
    if (additionalTypeDefs) {
        const sources = await load.loadTypedefs(additionalTypeDefs, {
            cwd: baseDir,
            loaders: [new codeFileLoader.CodeFileLoader(), new graphqlFileLoader.GraphQLFileLoader()],
        });
        return sources.map(source => source.document || utils$1.parseWithCache(source.rawSDL || utils.printSchemaWithDirectives(source.schema)));
    }
    return undefined;
}
async function resolveCache(cacheConfig = {
    localforage: {},
}, importFn, rootStore, cwd, pubsub, additionalPackagePrefixes) {
    const cacheName = Object.keys(cacheConfig)[0].toString();
    const config = cacheConfig[cacheName];
    const { moduleName, resolved: Cache } = await getPackage({
        name: cacheName,
        type: 'cache',
        importFn,
        cwd,
        additionalPrefixes: additionalPackagePrefixes,
    });
    const cache = new Cache({
        ...config,
        importFn,
        store: rootStore.child('cache'),
        pubsub,
    });
    const code = `const cache = new (MeshCache as any)({
      ...(${JSON.stringify(config)} as any),
      importFn,
      store: rootStore.child('cache'),
      pubsub,
    } as any)`;
    const importCode = `import MeshCache from ${JSON.stringify(moduleName)};`;
    return {
        cache,
        importCode,
        code,
    };
}
async function resolvePubSub(pubsubYamlConfig, importFn, cwd, additionalPackagePrefixes) {
    if (pubsubYamlConfig) {
        let pubsubName;
        let pubsubConfig;
        if (typeof pubsubYamlConfig === 'string') {
            pubsubName = pubsubYamlConfig;
        }
        else {
            pubsubName = pubsubYamlConfig.name;
            pubsubConfig = pubsubYamlConfig.config;
        }
        const { moduleName, resolved: PubSub } = await getPackage({
            name: pubsubName,
            type: 'pubsub',
            importFn,
            cwd,
            additionalPrefixes: additionalPackagePrefixes,
        });
        const pubsub = new PubSub(pubsubConfig);
        const importCode = `import PubSub from ${JSON.stringify(moduleName)}`;
        const code = `const pubsub = new PubSub(${JSON.stringify(pubsubConfig)});`;
        return {
            importCode,
            code,
            pubsub,
        };
    }
    else {
        const pubsub = new utils$1.PubSub();
        const importCode = `import { PubSub } from '@graphql-mesh/utils';`;
        const code = `const pubsub = new PubSub();`;
        return {
            importCode,
            code,
            pubsub,
        };
    }
}
async function resolveDocuments(documentsConfig, cwd) {
    if (!documentsConfig) {
        return [];
    }
    return load.loadDocuments(documentsConfig, {
        loaders: [new codeFileLoader.CodeFileLoader(), new graphqlFileLoader.GraphQLFileLoader()],
        skipGraphQLImport: true,
        cwd,
    });
}
async function resolveLogger(loggerConfig, importFn, cwd, additionalPackagePrefixes, initialLoggerPrefix = '🕸️  Mesh') {
    if (typeof loggerConfig === 'string') {
        const { moduleName, resolved: logger } = await getPackage({
            name: loggerConfig,
            type: 'logger',
            importFn,
            cwd,
            additionalPrefixes: additionalPackagePrefixes,
        });
        return {
            logger,
            importCode: `import logger from ${JSON.stringify(moduleName)};`,
            code: '',
        };
    }
    const logger = new utils$1.DefaultLogger(initialLoggerPrefix);
    return {
        logger,
        importCode: `import { DefaultLogger } from '@graphql-mesh/utils';`,
        code: `const logger = new DefaultLogger(${JSON.stringify(initialLoggerPrefix)});`,
    };
}

const ENVELOP_CORE_PLUGINS_MAP = {
    maskedErrors: {
        moduleName: '@envelop/core',
        importName: 'useMaskedErrors',
        pluginFactory: core.useMaskedErrors,
    },
    immediateIntrospection: {
        moduleName: '@envelop/core',
        importName: 'useImmediateIntrospection',
        pluginFactory: core.useImmediateIntrospection,
    },
};
function getDefaultMeshStore(dir, importFn, artifactsDir) {
    var _a;
    const isProd = ((_a = crossHelpers.process.env.NODE_ENV) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'production';
    const storeStorageAdapter = isProd
        ? new store.FsStoreStorageAdapter({
            cwd: dir,
            importFn,
            fileType: 'ts',
        })
        : new store.InMemoryStoreStorageAdapter();
    return new store.MeshStore(crossHelpers.path.resolve(dir, artifactsDir), storeStorageAdapter, {
        /**
         * TODO:
         * `mesh start` => { readonly: true, validate: false }
         * `mesh dev` => { readonly: false, validate: true } => validation error should show a prompt for confirmation
         * `mesh validate` => { readonly: true, validate: true } => should fetch from remote and try to update
         * readonly
         */
        readonly: isProd,
        validate: false,
    });
}
async function processConfig(config, options) {
    var _a, _b, _c;
    if (config.skipSSLValidation) {
        crossHelpers.process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
    }
    const importCodes = [
        `import type { GetMeshOptions } from '@graphql-mesh/runtime';`,
        `import type { YamlConfig } from '@graphql-mesh/types';`,
    ];
    const codes = [
        `export const rawServeConfig: YamlConfig.Config['serve'] = ${JSON.stringify(config.serve)} as any`,
        `export async function getMeshOptions(): Promise<GetMeshOptions> {`,
    ];
    const { dir, importFn = utils$1.defaultImportFn, store: providedStore, artifactsDir, additionalPackagePrefixes, } = options || {};
    if (config.require) {
        await Promise.all(config.require.map(mod => importFn(mod)));
        for (const mod of config.require) {
            importCodes.push(`import '${mod}';`);
        }
    }
    const rootStore = providedStore || getDefaultMeshStore(dir, importFn, artifactsDir || '.mesh');
    const { pubsub, importCode: pubsubImportCode, code: pubsubCode, } = await resolvePubSub(config.pubsub, importFn, dir, additionalPackagePrefixes);
    importCodes.push(pubsubImportCode);
    codes.push(pubsubCode);
    const { cache, importCode: cacheImportCode, code: cacheCode, } = await resolveCache(config.cache, importFn, rootStore, dir, pubsub, additionalPackagePrefixes);
    importCodes.push(cacheImportCode);
    codes.push(cacheCode);
    const sourcesStore = rootStore.child('sources');
    codes.push(`const sourcesStore = rootStore.child('sources');`);
    const { logger, importCode: loggerImportCode, code: loggerCode, } = await resolveLogger(config.logger, importFn, dir, additionalPackagePrefixes, options === null || options === void 0 ? void 0 : options.initialLoggerPrefix);
    importCodes.push(loggerImportCode);
    codes.push(loggerCode);
    codes.push(`const sources = [];`);
    codes.push(`const transforms = [];`);
    codes.push(`const additionalEnvelopPlugins = [];`);
    const mergerName = config.merger || (config.sources.length > 1 ? 'stitching' : 'bare');
    const [sources, transforms, additionalEnvelopPlugins, additionalTypeDefs, additionalResolvers, merger, documents] = await Promise.all([
        Promise.all(config.sources.map(async (source, sourceIndex) => {
            const handlerName = Object.keys(source.handler)[0].toString();
            const handlerConfig = source.handler[handlerName];
            const handlerVariableName = camelCase.camelCase(`${source.name}_Handler`);
            const transformsVariableName = camelCase.camelCase(`${source.name}_Transforms`);
            codes.push(`const ${transformsVariableName} = [];`);
            const [handler, transforms] = await Promise.all([
                await getPackage({
                    name: handlerName,
                    type: 'handler',
                    importFn,
                    cwd: dir,
                    additionalPrefixes: additionalPackagePrefixes,
                }).then(({ resolved: HandlerCtor, moduleName }) => {
                    if (options.generateCode) {
                        const handlerImportName = pascalCase.pascalCase(handlerName + '_Handler');
                        importCodes.push(`import ${handlerImportName} from ${JSON.stringify(moduleName)}`);
                        codes.push(`const ${handlerVariableName} = new ${handlerImportName}({
              name: ${JSON.stringify(source.name)},
              config: ${JSON.stringify(handlerConfig)},
              baseDir,
              cache,
              pubsub,
              store: sourcesStore.child(${JSON.stringify(source.name)}),
              logger: logger.child(${JSON.stringify(source.name)}),
              importFn
            });`);
                    }
                    return new HandlerCtor({
                        name: source.name,
                        config: handlerConfig,
                        baseDir: dir,
                        cache,
                        pubsub,
                        store: sourcesStore.child(source.name),
                        logger: logger.child(source.name),
                        importFn,
                    });
                }),
                Promise.all((source.transforms || []).map(async (t, transformIndex) => {
                    const transformName = Object.keys(t)[0].toString();
                    const transformConfig = t[transformName];
                    const { resolved: TransformCtor, moduleName } = await getPackage({
                        name: transformName,
                        type: 'transform',
                        importFn,
                        cwd: dir,
                        additionalPrefixes: additionalPackagePrefixes,
                    });
                    if (options.generateCode) {
                        const transformImportName = pascalCase.pascalCase(transformName + '_Transform');
                        importCodes.push(`import ${transformImportName} from ${JSON.stringify(moduleName)};`);
                        codes.push(`${transformsVariableName}[${transformIndex}] = new ${transformImportName}({
                  apiName: ${JSON.stringify(source.name)},
                  config: ${JSON.stringify(transformConfig)},
                  baseDir,
                  cache,
                  pubsub,
                  importFn
                });`);
                    }
                    return new TransformCtor({
                        apiName: source.name,
                        config: transformConfig,
                        baseDir: dir,
                        cache,
                        pubsub,
                        importFn,
                    });
                })),
            ]);
            if (options.generateCode) {
                codes.push(`sources[${sourceIndex}] = {
          name: '${source.name}',
          handler: ${handlerVariableName},
          transforms: ${transformsVariableName}
        }`);
            }
            return {
                name: source.name,
                handler,
                transforms,
            };
        })),
        Promise.all(((_a = config.transforms) === null || _a === void 0 ? void 0 : _a.map(async (t, transformIndex) => {
            const transformName = Object.keys(t)[0].toString();
            const transformConfig = t[transformName];
            const { resolved: TransformLibrary, moduleName } = await getPackage({
                name: transformName,
                type: 'transform',
                importFn,
                cwd: dir,
                additionalPrefixes: additionalPackagePrefixes,
            });
            if (options.generateCode) {
                const transformImportName = pascalCase.pascalCase(transformName + '_Transform');
                importCodes.push(`import ${transformImportName} from ${JSON.stringify(moduleName)};`);
                codes.push(`transforms[${transformIndex}] = new (${transformImportName} as any)({
            apiName: '',
            config: ${JSON.stringify(transformConfig)},
            baseDir,
            cache,
            pubsub,
            importFn
          })`);
            }
            return new TransformLibrary({
                apiName: '',
                config: transformConfig,
                baseDir: dir,
                cache,
                pubsub,
                importFn,
            });
        })) || []),
        Promise.all(((_b = config.plugins) === null || _b === void 0 ? void 0 : _b.map(async (p, pluginIndex) => {
            const pluginName = Object.keys(p)[0].toString();
            const pluginConfig = p[pluginName];
            if (ENVELOP_CORE_PLUGINS_MAP[pluginName] != null) {
                const { importName, moduleName, pluginFactory } = ENVELOP_CORE_PLUGINS_MAP[pluginName];
                if (options.generateCode) {
                    importCodes.push(`import { ${importName} } from ${JSON.stringify(moduleName)};`);
                    codes.push(`additionalEnvelopPlugins[${pluginIndex}] = ${importName}(${JSON.stringify(pluginConfig, null, 2)}))`);
                }
                return pluginFactory(pluginConfig);
            }
            let importName;
            const { resolved: possiblePluginFactory, moduleName } = await getPackage({
                name: pluginName,
                type: 'plugin',
                importFn,
                cwd: dir,
                additionalPrefixes: [...additionalPackagePrefixes, '@envelop/'],
            });
            let pluginFactory;
            if (typeof possiblePluginFactory === 'function') {
                pluginFactory = possiblePluginFactory;
                if (options.generateCode) {
                    importName = pascalCase.pascalCase('use_' + pluginName);
                    importCodes.push(`import ${importName} from ${JSON.stringify(moduleName)};`);
                    codes.push(`additionalEnvelopPlugins[${pluginIndex}] = ${importName}({
          ...(${JSON.stringify(pluginConfig, null, 2)}),
          logger: logger.child(${JSON.stringify(pluginName)}),
        })`);
                }
            }
            else {
                Object.keys(possiblePluginFactory).forEach(key => {
                    if (key.toString().startsWith('use') && typeof possiblePluginFactory[key] === 'function') {
                        pluginFactory = possiblePluginFactory[key];
                        if (options.generateCode) {
                            importCodes.push(`import { ${importName} } from ${JSON.stringify(moduleName)};`);
                            codes.push(`additionalEnvelopPlugins[${pluginIndex}] = ${importName}(${JSON.stringify(pluginConfig, null, 2)}]`);
                        }
                    }
                });
            }
            return pluginFactory({
                ...pluginConfig,
                logger: logger.child(pluginName),
            });
        })) || []),
        resolveAdditionalTypeDefs(dir, config.additionalTypeDefs).then(additionalTypeDefs => {
            if (options.generateCode) {
                codes.push(`const additionalTypeDefs = [${(additionalTypeDefs || []).map(parsedTypeDefs => `parse(${JSON.stringify(graphql.print(parsedTypeDefs))}),`)}] as any[];`);
                if (additionalTypeDefs === null || additionalTypeDefs === void 0 ? void 0 : additionalTypeDefs.length) {
                    importCodes.push(`import { parse } from 'graphql';`);
                }
            }
            return additionalTypeDefs;
        }),
        (options === null || options === void 0 ? void 0 : options.ignoreAdditionalResolvers)
            ? []
            : utils$1.resolveAdditionalResolvers(dir, config.additionalResolvers, importFn, pubsub),
        getPackage({
            name: mergerName,
            type: 'merger',
            importFn,
            cwd: dir,
            additionalPrefixes: additionalPackagePrefixes,
        }).then(({ resolved: Merger, moduleName }) => {
            if (options.generateCode) {
                const mergerImportName = pascalCase.pascalCase(`${mergerName}Merger`);
                importCodes.push(`import ${mergerImportName} from ${JSON.stringify(moduleName)};`);
                codes.push(`const merger = new(${mergerImportName} as any)({
        cache,
        pubsub,
        logger: logger.child('${mergerName}Merger'),
        store: rootStore.child('${mergerName}Merger')
      })`);
            }
            return new Merger({
                cache,
                pubsub,
                logger: logger.child(`${mergerName}Merger`),
                store: rootStore.child(`${mergerName}Merger`),
            });
        }),
        resolveDocuments(config.documents, dir),
    ]);
    if (options.generateCode) {
        if ((_c = config.additionalResolvers) === null || _c === void 0 ? void 0 : _c.length) {
            importCodes.push(`import { resolveAdditionalResolversWithoutImport } from '@graphql-mesh/utils';`);
            codes.push(`const additionalResolvers = await Promise.all([
        ${config.additionalResolvers
                .map(additionalResolverDefinition => {
                if (typeof additionalResolverDefinition === 'string') {
                    return `import(${JSON.stringify(crossHelpers.path.join('..', additionalResolverDefinition).split('\\').join('/'))})
            .then(m => m.resolvers || m.default || m)`;
                }
                else {
                    return `resolveAdditionalResolversWithoutImport(
            ${JSON.stringify(additionalResolverDefinition, null, 2)}
          )`;
                }
            })
                .join(',\n')}
      ]);`);
        }
        else {
            codes.push(`const additionalResolvers = [] as any[]`);
        }
    }
    if (config.additionalEnvelopPlugins) {
        codes.push(`const importedAdditionalEnvelopPlugins = await import(${JSON.stringify(crossHelpers.path.join('..', config.additionalEnvelopPlugins).split('\\').join('/'))}).then(m => m.default || m);`);
        const importedAdditionalEnvelopPlugins = await importFn(crossHelpers.path.isAbsolute(config.additionalEnvelopPlugins)
            ? config.additionalEnvelopPlugins
            : crossHelpers.path.join(dir, config.additionalEnvelopPlugins));
        if (typeof importedAdditionalEnvelopPlugins === 'function') {
            const factoryResult = await importedAdditionalEnvelopPlugins(config);
            if (Array.isArray(factoryResult)) {
                if (options.generateCode) {
                    codes.push(`additionalEnvelopPlugins.push(...(await importedAdditionalEnvelopPlugins()));`);
                }
                additionalEnvelopPlugins.push(...factoryResult);
            }
            else {
                if (options.generateCode) {
                    codes.push(`additionalEnvelopPlugins.push(await importedAdditionalEnvelopPlugins());`);
                }
                additionalEnvelopPlugins.push(factoryResult);
            }
        }
        else {
            if (Array.isArray(importedAdditionalEnvelopPlugins)) {
                if (options.generateCode) {
                    codes.push(`additionalEnvelopPlugins.push(...importedAdditionalEnvelopPlugins)`);
                }
                additionalEnvelopPlugins.push(...importedAdditionalEnvelopPlugins);
            }
            else {
                if (options.generateCode) {
                    codes.push(`additionalEnvelopPlugins.push(importedAdditionalEnvelopPlugins)`);
                }
                additionalEnvelopPlugins.push(importedAdditionalEnvelopPlugins);
            }
        }
    }
    if (options.generateCode) {
        importCodes.push(`import { printWithCache } from '@graphql-mesh/utils';`);
        const documentVariableNames = [];
        if (documents === null || documents === void 0 ? void 0 : documents.length) {
            const allDocumentNodes = graphql.concatAST(documents.map(document => document.document || utils$1.parseWithCache(document.rawSDL)));
            graphql.visit(allDocumentNodes, {
                OperationDefinition(node) {
                    documentVariableNames.push(pascalCase.pascalCase(node.name.value + '_Document'));
                },
            });
        }
        codes.push(`
  return {
    sources,
    transforms,
    additionalTypeDefs,
    additionalResolvers,
    cache,
    pubsub,
    merger,
    logger,
    additionalEnvelopPlugins,
    get documents() {
      return [
      ${documentVariableNames
            .map(documentVarName => `{
        document: ${documentVarName},
        get rawSDL() {
          return printWithCache(${documentVarName});
        },
        location: '${documentVarName}.graphql'
      }`)
            .join(',')}
    ];
    },
  };
}`);
    }
    return {
        sources,
        transforms,
        additionalTypeDefs,
        additionalResolvers,
        cache,
        merger,
        pubsub,
        config,
        documents,
        logger,
        store: rootStore,
        additionalEnvelopPlugins,
        code: [...new Set([...importCodes, ...codes])].join('\n'),
    };
}

exports.getPackage = getPackage;
exports.processConfig = processConfig;
exports.resolveAdditionalTypeDefs = resolveAdditionalTypeDefs;
exports.resolveCache = resolveCache;
exports.resolveDocuments = resolveDocuments;
exports.resolveLogger = resolveLogger;
exports.resolvePubSub = resolvePubSub;
