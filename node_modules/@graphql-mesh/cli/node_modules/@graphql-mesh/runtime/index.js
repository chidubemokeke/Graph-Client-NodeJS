'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const graphql = require('graphql');
const utils = require('@graphql-mesh/utils');
const delegate = require('@graphql-tools/delegate');
const batchDelegate = require('@graphql-tools/batch-delegate');
const wrap = require('@graphql-tools/wrap');
const utils$1 = require('@graphql-tools/utils');
const core = require('@envelop/core');
const extendedValidation = require('@envelop/extended-validation');

const MESH_CONTEXT_SYMBOL = Symbol('isMeshContext');
const MESH_API_CONTEXT_SYMBOL = Symbol('isMeshAPIContext');

const memoizedGetOperationType = utils$1.memoize1((document) => {
    const operationAST = graphql.getOperationAST(document, undefined);
    if (!operationAST) {
        throw new Error('Must provide document with a valid operation');
    }
    return operationAST.operation;
});
const memoizedGetEnvelopedFactory = utils$1.memoize1(function getEnvelopedFactory(plugins) {
    const getEnveloped = core.envelop({ plugins });
    return utils$1.memoize1(function getEnvelopedByContext(initialContext) {
        return getEnveloped(initialContext);
    });
});
async function getMesh(options) {
    const rawSources = [];
    const { pubsub = new utils.PubSub(), cache, logger = new utils.DefaultLogger('ðŸ•¸ï¸  Mesh'), additionalEnvelopPlugins = [], sources, merger, additionalResolvers, additionalTypeDefs, transforms, } = options;
    const getMeshLogger = logger.child('GetMesh');
    getMeshLogger.debug(`Getting subschemas from source handlers`);
    let failed = false;
    await Promise.allSettled(sources.map(async (apiSource) => {
        const apiName = apiSource.name;
        const sourceLogger = logger.child(apiName);
        sourceLogger.debug(`Generating the schema`);
        try {
            const source = await apiSource.handler.getMeshSource();
            sourceLogger.debug(`The schema has been generated successfully`);
            let apiSchema = source.schema;
            sourceLogger.debug(`Analyzing transforms`);
            let transforms;
            const { wrapTransforms, noWrapTransforms } = utils.groupTransforms(apiSource.transforms);
            if (!(wrapTransforms === null || wrapTransforms === void 0 ? void 0 : wrapTransforms.length) && (noWrapTransforms === null || noWrapTransforms === void 0 ? void 0 : noWrapTransforms.length)) {
                sourceLogger.debug(`${noWrapTransforms.length} bare transforms found and applying`);
                apiSchema = utils.applySchemaTransforms(apiSchema, source, null, noWrapTransforms);
            }
            else {
                transforms = apiSource.transforms;
            }
            rawSources.push({
                name: apiName,
                schema: apiSchema,
                executor: source.executor,
                transforms,
                contextVariables: source.contextVariables || {},
                handler: apiSource.handler,
                batch: 'batch' in source ? source.batch : true,
                merge: apiSource.merge,
            });
        }
        catch (e) {
            sourceLogger.error(`Failed to generate the schema`, e);
            failed = true;
        }
    }));
    if (failed) {
        throw new Error(`Schemas couldn't be generated successfully. Check for the logs by running Mesh with DEBUG=1 environmental variable to get more verbose output.`);
    }
    getMeshLogger.debug(`Schemas have been generated by the source handlers`);
    getMeshLogger.debug(`Merging schemas using the defined merging strategy.`);
    const unifiedSchema = await merger.getUnifiedSchema({
        rawSources,
        typeDefs: additionalTypeDefs,
        resolvers: additionalResolvers,
        transforms,
    });
    getMeshLogger.debug(`Building Mesh Context`);
    const meshContext = {
        pubsub,
        cache,
        logger,
        [MESH_CONTEXT_SYMBOL]: true,
    };
    getMeshLogger.debug(`Attaching in-context SDK, pubsub and cache to the context`);
    const sourceMap = unifiedSchema.extensions.sourceMap;
    await Promise.all(rawSources.map(async (rawSource) => {
        const rawSourceLogger = logger.child(`${rawSource.name}`);
        const rawSourceContext = {
            rawSource,
            [MESH_API_CONTEXT_SYMBOL]: true,
        };
        // TODO: Somehow rawSource reference got lost in somewhere
        let rawSourceSubSchemaConfig;
        const stitchingInfo = unifiedSchema.extensions.stitchingInfo;
        if (stitchingInfo) {
            for (const [subschemaConfig, subschema] of stitchingInfo.subschemaMap) {
                if (subschemaConfig.name === rawSource.name) {
                    rawSourceSubSchemaConfig = subschema;
                    break;
                }
            }
        }
        else {
            rawSourceSubSchemaConfig = rawSource;
        }
        const transformedSchema = sourceMap.get(rawSource);
        const rootTypes = {
            query: transformedSchema.getQueryType(),
            mutation: transformedSchema.getMutationType(),
            subscription: transformedSchema.getSubscriptionType(),
        };
        rawSourceLogger.debug(`Generating In Context SDK`);
        for (const operationType in rootTypes) {
            const rootType = rootTypes[operationType];
            if (rootType) {
                rawSourceContext[rootType.name] = {};
                const rootTypeFieldMap = rootType.getFields();
                for (const fieldName in rootTypeFieldMap) {
                    const rootTypeField = rootTypeFieldMap[fieldName];
                    const inContextSdkLogger = rawSourceLogger.child(`InContextSDK.${rootType.name}.${fieldName}`);
                    const namedReturnType = graphql.getNamedType(rootTypeField.type);
                    const shouldHaveSelectionSet = !graphql.isLeafType(namedReturnType);
                    rawSourceContext[rootType.name][fieldName] = ({ root, args, context, info = {
                        fieldName,
                        fieldNodes: [],
                        returnType: namedReturnType,
                        parentType: rootType,
                        path: {
                            typename: rootType.name,
                            key: fieldName,
                            prev: undefined,
                        },
                        schema: transformedSchema,
                        fragments: {},
                        rootValue: root,
                        operation: {
                            kind: graphql.Kind.OPERATION_DEFINITION,
                            operation: operationType,
                            selectionSet: {
                                kind: graphql.Kind.SELECTION_SET,
                                selections: [],
                            },
                        },
                        variableValues: {},
                        cacheControl: {
                            setCacheHint: () => { },
                            cacheHint: {},
                        },
                    }, selectionSet, key, argsFromKeys, valuesFromResults, }) => {
                        inContextSdkLogger.debug(`Called with`, {
                            args,
                            key,
                        });
                        const commonDelegateOptions = {
                            schema: rawSourceSubSchemaConfig,
                            rootValue: root,
                            operation: operationType,
                            fieldName,
                            context,
                            transformedSchema,
                            info,
                        };
                        // If there isn't an extraction of a value
                        if (typeof selectionSet !== 'function') {
                            commonDelegateOptions.returnType = rootTypeField.type;
                        }
                        if (shouldHaveSelectionSet) {
                            let selectionCount = 0;
                            for (const fieldNode of info.fieldNodes) {
                                if (fieldNode.selectionSet != null) {
                                    selectionCount += fieldNode.selectionSet.selections.length;
                                }
                            }
                            if (selectionCount === 0) {
                                if (!selectionSet) {
                                    throw new Error(`You have to provide 'selectionSet' for context.${rawSource.name}.${rootType.name}.${fieldName}`);
                                }
                                commonDelegateOptions.info = {
                                    ...info,
                                    fieldNodes: [
                                        {
                                            ...info.fieldNodes[0],
                                            selectionSet: {
                                                kind: graphql.Kind.SELECTION_SET,
                                                selections: [
                                                    {
                                                        kind: graphql.Kind.FIELD,
                                                        name: {
                                                            kind: graphql.Kind.NAME,
                                                            value: '__typename',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                        ...info.fieldNodes.slice(1),
                                    ],
                                };
                            }
                        }
                        if (key && argsFromKeys) {
                            const batchDelegationOptions = {
                                ...commonDelegateOptions,
                                key,
                                argsFromKeys,
                                valuesFromResults,
                            };
                            if (selectionSet) {
                                const selectionSetFactory = normalizeSelectionSetParamOrFactory(selectionSet);
                                const path = [fieldName];
                                const wrapQueryTransform = new wrap.WrapQuery(path, selectionSetFactory, identical);
                                batchDelegationOptions.transforms = [wrapQueryTransform];
                            }
                            return batchDelegate.batchDelegateToSchema(batchDelegationOptions);
                        }
                        else {
                            const regularDelegateOptions = {
                                ...commonDelegateOptions,
                                args,
                            };
                            if (selectionSet) {
                                const selectionSetFactory = normalizeSelectionSetParamOrFactory(selectionSet);
                                const path = [fieldName];
                                const wrapQueryTransform = new wrap.WrapQuery(path, selectionSetFactory, valuesFromResults || identical);
                                regularDelegateOptions.transforms = [wrapQueryTransform];
                            }
                            return delegate.delegateToSchema(regularDelegateOptions);
                        }
                    };
                }
            }
        }
        meshContext[rawSource.name] = rawSourceContext;
    }));
    const plugins = [
        core.useSchema(unifiedSchema),
        core.useExtendContext(() => meshContext),
        core.enableIf(!!unifiedSchema.getDirective('oneOf'), () => extendedValidation.useExtendedValidation({
            rules: [extendedValidation.OneOfInputObjectsRule],
        })),
        {
            onParse({ setParseFn }) {
                setParseFn(utils.parseWithCache);
            },
        },
        ...additionalEnvelopPlugins,
    ];
    const EMPTY_ROOT_VALUE = {};
    const EMPTY_CONTEXT_VALUE = {};
    const EMPTY_VARIABLES_VALUE = {};
    async function meshExecute(documentOrSDL, variableValues = EMPTY_VARIABLES_VALUE, contextValue = EMPTY_CONTEXT_VALUE, rootValue = EMPTY_ROOT_VALUE, operationName) {
        const getEnveloped = memoizedGetEnvelopedFactory(plugins);
        const { execute, contextFactory, parse } = getEnveloped(contextValue);
        return execute({
            document: typeof documentOrSDL === 'string' ? parse(documentOrSDL) : documentOrSDL,
            contextValue: await contextFactory(),
            rootValue,
            variableValues: variableValues,
            schema: unifiedSchema,
            operationName,
        });
    }
    async function meshSubscribe(documentOrSDL, variableValues = EMPTY_VARIABLES_VALUE, contextValue = EMPTY_CONTEXT_VALUE, rootValue = EMPTY_ROOT_VALUE, operationName) {
        const getEnveloped = memoizedGetEnvelopedFactory(plugins);
        const { subscribe, contextFactory, parse } = getEnveloped(contextValue);
        return subscribe({
            document: typeof documentOrSDL === 'string' ? parse(documentOrSDL) : documentOrSDL,
            contextValue: await contextFactory(),
            rootValue,
            variableValues: variableValues,
            schema: unifiedSchema,
            operationName,
        });
    }
    function sdkRequesterFactory(globalContext) {
        return async function meshSdkRequester(document, variables, contextValue) {
            var _a, _b;
            if (memoizedGetOperationType(document) === 'subscription') {
                const result = await meshSubscribe(document, variables, {
                    ...globalContext,
                    ...contextValue,
                });
                if (utils$1.isAsyncIterable(result)) {
                    return utils$1.mapAsyncIterator(result, result => {
                        var _a;
                        if ((_a = result === null || result === void 0 ? void 0 : result.errors) === null || _a === void 0 ? void 0 : _a.length) {
                            return new utils$1.AggregateError(result.errors);
                        }
                        return result === null || result === void 0 ? void 0 : result.data;
                    });
                }
                if ((_a = result === null || result === void 0 ? void 0 : result.errors) === null || _a === void 0 ? void 0 : _a.length) {
                    return new utils$1.AggregateError(result.errors);
                }
                return result === null || result === void 0 ? void 0 : result.data;
            }
            else {
                const result = await meshExecute(document, variables, {
                    ...globalContext,
                    ...contextValue,
                });
                if ((_b = result === null || result === void 0 ? void 0 : result.errors) === null || _b === void 0 ? void 0 : _b.length) {
                    return new utils$1.AggregateError(result.errors);
                }
                return result === null || result === void 0 ? void 0 : result.data;
            }
        };
    }
    return {
        execute: meshExecute,
        subscribe: meshSubscribe,
        schema: unifiedSchema,
        rawSources,
        cache,
        pubsub,
        destroy() {
            return pubsub.publish('destroy', undefined);
        },
        logger,
        meshContext: meshContext,
        plugins,
        get getEnveloped() {
            return memoizedGetEnvelopedFactory(plugins);
        },
        sdkRequesterFactory,
    };
}
function normalizeSelectionSetParam(selectionSetParam) {
    if (typeof selectionSetParam === 'string') {
        return utils$1.parseSelectionSet(selectionSetParam);
    }
    if (utils$1.isDocumentNode(selectionSetParam)) {
        return utils$1.parseSelectionSet(graphql.print(selectionSetParam));
    }
    return selectionSetParam;
}
function normalizeSelectionSetParamOrFactory(selectionSetParamOrFactory) {
    return function getSelectionSet(subtree) {
        if (typeof selectionSetParamOrFactory === 'function') {
            const selectionSetParam = selectionSetParamOrFactory(subtree);
            return normalizeSelectionSetParam(selectionSetParam);
        }
        else {
            return normalizeSelectionSetParam(selectionSetParamOrFactory);
        }
    };
}
function identical(val) {
    return val;
}

exports.getMesh = getMesh;
