import { getOperationAST, getNamedType, isLeafType, Kind, print } from 'graphql';
import { PubSub, DefaultLogger, groupTransforms, applySchemaTransforms, parseWithCache } from '@graphql-mesh/utils';
import { delegateToSchema } from '@graphql-tools/delegate';
import { batchDelegateToSchema } from '@graphql-tools/batch-delegate';
import { WrapQuery } from '@graphql-tools/wrap';
import { memoize1, isAsyncIterable, mapAsyncIterator, AggregateError, parseSelectionSet, isDocumentNode } from '@graphql-tools/utils';
import { envelop, useSchema, useExtendContext, enableIf } from '@envelop/core';
import { useExtendedValidation, OneOfInputObjectsRule } from '@envelop/extended-validation';

const MESH_CONTEXT_SYMBOL = Symbol('isMeshContext');
const MESH_API_CONTEXT_SYMBOL = Symbol('isMeshAPIContext');

const memoizedGetOperationType = memoize1((document) => {
    const operationAST = getOperationAST(document, undefined);
    if (!operationAST) {
        throw new Error('Must provide document with a valid operation');
    }
    return operationAST.operation;
});
const memoizedGetEnvelopedFactory = memoize1(function getEnvelopedFactory(plugins) {
    const getEnveloped = envelop({ plugins });
    return memoize1(function getEnvelopedByContext(initialContext) {
        return getEnveloped(initialContext);
    });
});
async function getMesh(options) {
    const rawSources = [];
    const { pubsub = new PubSub(), cache, logger = new DefaultLogger('ðŸ•¸ï¸  Mesh'), additionalEnvelopPlugins = [], sources, merger, additionalResolvers, additionalTypeDefs, transforms, } = options;
    const getMeshLogger = logger.child('GetMesh');
    getMeshLogger.debug(`Getting subschemas from source handlers`);
    let failed = false;
    await Promise.allSettled(sources.map(async (apiSource) => {
        const apiName = apiSource.name;
        const sourceLogger = logger.child(apiName);
        sourceLogger.debug(`Generating the schema`);
        try {
            const source = await apiSource.handler.getMeshSource();
            sourceLogger.debug(`The schema has been generated successfully`);
            let apiSchema = source.schema;
            sourceLogger.debug(`Analyzing transforms`);
            let transforms;
            const { wrapTransforms, noWrapTransforms } = groupTransforms(apiSource.transforms);
            if (!(wrapTransforms === null || wrapTransforms === void 0 ? void 0 : wrapTransforms.length) && (noWrapTransforms === null || noWrapTransforms === void 0 ? void 0 : noWrapTransforms.length)) {
                sourceLogger.debug(`${noWrapTransforms.length} bare transforms found and applying`);
                apiSchema = applySchemaTransforms(apiSchema, source, null, noWrapTransforms);
            }
            else {
                transforms = apiSource.transforms;
            }
            rawSources.push({
                name: apiName,
                schema: apiSchema,
                executor: source.executor,
                transforms,
                contextVariables: source.contextVariables || {},
                handler: apiSource.handler,
                batch: 'batch' in source ? source.batch : true,
                merge: apiSource.merge,
            });
        }
        catch (e) {
            sourceLogger.error(`Failed to generate the schema`, e);
            failed = true;
        }
    }));
    if (failed) {
        throw new Error(`Schemas couldn't be generated successfully. Check for the logs by running Mesh with DEBUG=1 environmental variable to get more verbose output.`);
    }
    getMeshLogger.debug(`Schemas have been generated by the source handlers`);
    getMeshLogger.debug(`Merging schemas using the defined merging strategy.`);
    const unifiedSchema = await merger.getUnifiedSchema({
        rawSources,
        typeDefs: additionalTypeDefs,
        resolvers: additionalResolvers,
        transforms,
    });
    getMeshLogger.debug(`Building Mesh Context`);
    const meshContext = {
        pubsub,
        cache,
        logger,
        [MESH_CONTEXT_SYMBOL]: true,
    };
    getMeshLogger.debug(`Attaching in-context SDK, pubsub and cache to the context`);
    const sourceMap = unifiedSchema.extensions.sourceMap;
    await Promise.all(rawSources.map(async (rawSource) => {
        const rawSourceLogger = logger.child(`${rawSource.name}`);
        const rawSourceContext = {
            rawSource,
            [MESH_API_CONTEXT_SYMBOL]: true,
        };
        // TODO: Somehow rawSource reference got lost in somewhere
        let rawSourceSubSchemaConfig;
        const stitchingInfo = unifiedSchema.extensions.stitchingInfo;
        if (stitchingInfo) {
            for (const [subschemaConfig, subschema] of stitchingInfo.subschemaMap) {
                if (subschemaConfig.name === rawSource.name) {
                    rawSourceSubSchemaConfig = subschema;
                    break;
                }
            }
        }
        else {
            rawSourceSubSchemaConfig = rawSource;
        }
        const transformedSchema = sourceMap.get(rawSource);
        const rootTypes = {
            query: transformedSchema.getQueryType(),
            mutation: transformedSchema.getMutationType(),
            subscription: transformedSchema.getSubscriptionType(),
        };
        rawSourceLogger.debug(`Generating In Context SDK`);
        for (const operationType in rootTypes) {
            const rootType = rootTypes[operationType];
            if (rootType) {
                rawSourceContext[rootType.name] = {};
                const rootTypeFieldMap = rootType.getFields();
                for (const fieldName in rootTypeFieldMap) {
                    const rootTypeField = rootTypeFieldMap[fieldName];
                    const inContextSdkLogger = rawSourceLogger.child(`InContextSDK.${rootType.name}.${fieldName}`);
                    const namedReturnType = getNamedType(rootTypeField.type);
                    const shouldHaveSelectionSet = !isLeafType(namedReturnType);
                    rawSourceContext[rootType.name][fieldName] = ({ root, args, context, info = {
                        fieldName,
                        fieldNodes: [],
                        returnType: namedReturnType,
                        parentType: rootType,
                        path: {
                            typename: rootType.name,
                            key: fieldName,
                            prev: undefined,
                        },
                        schema: transformedSchema,
                        fragments: {},
                        rootValue: root,
                        operation: {
                            kind: Kind.OPERATION_DEFINITION,
                            operation: operationType,
                            selectionSet: {
                                kind: Kind.SELECTION_SET,
                                selections: [],
                            },
                        },
                        variableValues: {},
                        cacheControl: {
                            setCacheHint: () => { },
                            cacheHint: {},
                        },
                    }, selectionSet, key, argsFromKeys, valuesFromResults, }) => {
                        inContextSdkLogger.debug(`Called with`, {
                            args,
                            key,
                        });
                        const commonDelegateOptions = {
                            schema: rawSourceSubSchemaConfig,
                            rootValue: root,
                            operation: operationType,
                            fieldName,
                            context,
                            transformedSchema,
                            info,
                        };
                        // If there isn't an extraction of a value
                        if (typeof selectionSet !== 'function') {
                            commonDelegateOptions.returnType = rootTypeField.type;
                        }
                        if (shouldHaveSelectionSet) {
                            let selectionCount = 0;
                            for (const fieldNode of info.fieldNodes) {
                                if (fieldNode.selectionSet != null) {
                                    selectionCount += fieldNode.selectionSet.selections.length;
                                }
                            }
                            if (selectionCount === 0) {
                                if (!selectionSet) {
                                    throw new Error(`You have to provide 'selectionSet' for context.${rawSource.name}.${rootType.name}.${fieldName}`);
                                }
                                commonDelegateOptions.info = {
                                    ...info,
                                    fieldNodes: [
                                        {
                                            ...info.fieldNodes[0],
                                            selectionSet: {
                                                kind: Kind.SELECTION_SET,
                                                selections: [
                                                    {
                                                        kind: Kind.FIELD,
                                                        name: {
                                                            kind: Kind.NAME,
                                                            value: '__typename',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                        ...info.fieldNodes.slice(1),
                                    ],
                                };
                            }
                        }
                        if (key && argsFromKeys) {
                            const batchDelegationOptions = {
                                ...commonDelegateOptions,
                                key,
                                argsFromKeys,
                                valuesFromResults,
                            };
                            if (selectionSet) {
                                const selectionSetFactory = normalizeSelectionSetParamOrFactory(selectionSet);
                                const path = [fieldName];
                                const wrapQueryTransform = new WrapQuery(path, selectionSetFactory, identical);
                                batchDelegationOptions.transforms = [wrapQueryTransform];
                            }
                            return batchDelegateToSchema(batchDelegationOptions);
                        }
                        else {
                            const regularDelegateOptions = {
                                ...commonDelegateOptions,
                                args,
                            };
                            if (selectionSet) {
                                const selectionSetFactory = normalizeSelectionSetParamOrFactory(selectionSet);
                                const path = [fieldName];
                                const wrapQueryTransform = new WrapQuery(path, selectionSetFactory, valuesFromResults || identical);
                                regularDelegateOptions.transforms = [wrapQueryTransform];
                            }
                            return delegateToSchema(regularDelegateOptions);
                        }
                    };
                }
            }
        }
        meshContext[rawSource.name] = rawSourceContext;
    }));
    const plugins = [
        useSchema(unifiedSchema),
        useExtendContext(() => meshContext),
        enableIf(!!unifiedSchema.getDirective('oneOf'), () => useExtendedValidation({
            rules: [OneOfInputObjectsRule],
        })),
        {
            onParse({ setParseFn }) {
                setParseFn(parseWithCache);
            },
        },
        ...additionalEnvelopPlugins,
    ];
    const EMPTY_ROOT_VALUE = {};
    const EMPTY_CONTEXT_VALUE = {};
    const EMPTY_VARIABLES_VALUE = {};
    async function meshExecute(documentOrSDL, variableValues = EMPTY_VARIABLES_VALUE, contextValue = EMPTY_CONTEXT_VALUE, rootValue = EMPTY_ROOT_VALUE, operationName) {
        const getEnveloped = memoizedGetEnvelopedFactory(plugins);
        const { execute, contextFactory, parse } = getEnveloped(contextValue);
        return execute({
            document: typeof documentOrSDL === 'string' ? parse(documentOrSDL) : documentOrSDL,
            contextValue: await contextFactory(),
            rootValue,
            variableValues: variableValues,
            schema: unifiedSchema,
            operationName,
        });
    }
    async function meshSubscribe(documentOrSDL, variableValues = EMPTY_VARIABLES_VALUE, contextValue = EMPTY_CONTEXT_VALUE, rootValue = EMPTY_ROOT_VALUE, operationName) {
        const getEnveloped = memoizedGetEnvelopedFactory(plugins);
        const { subscribe, contextFactory, parse } = getEnveloped(contextValue);
        return subscribe({
            document: typeof documentOrSDL === 'string' ? parse(documentOrSDL) : documentOrSDL,
            contextValue: await contextFactory(),
            rootValue,
            variableValues: variableValues,
            schema: unifiedSchema,
            operationName,
        });
    }
    function sdkRequesterFactory(globalContext) {
        return async function meshSdkRequester(document, variables, contextValue) {
            var _a, _b;
            if (memoizedGetOperationType(document) === 'subscription') {
                const result = await meshSubscribe(document, variables, {
                    ...globalContext,
                    ...contextValue,
                });
                if (isAsyncIterable(result)) {
                    return mapAsyncIterator(result, result => {
                        var _a;
                        if ((_a = result === null || result === void 0 ? void 0 : result.errors) === null || _a === void 0 ? void 0 : _a.length) {
                            return new AggregateError(result.errors);
                        }
                        return result === null || result === void 0 ? void 0 : result.data;
                    });
                }
                if ((_a = result === null || result === void 0 ? void 0 : result.errors) === null || _a === void 0 ? void 0 : _a.length) {
                    return new AggregateError(result.errors);
                }
                return result === null || result === void 0 ? void 0 : result.data;
            }
            else {
                const result = await meshExecute(document, variables, {
                    ...globalContext,
                    ...contextValue,
                });
                if ((_b = result === null || result === void 0 ? void 0 : result.errors) === null || _b === void 0 ? void 0 : _b.length) {
                    return new AggregateError(result.errors);
                }
                return result === null || result === void 0 ? void 0 : result.data;
            }
        };
    }
    return {
        execute: meshExecute,
        subscribe: meshSubscribe,
        schema: unifiedSchema,
        rawSources,
        cache,
        pubsub,
        destroy() {
            return pubsub.publish('destroy', undefined);
        },
        logger,
        meshContext: meshContext,
        plugins,
        get getEnveloped() {
            return memoizedGetEnvelopedFactory(plugins);
        },
        sdkRequesterFactory,
    };
}
function normalizeSelectionSetParam(selectionSetParam) {
    if (typeof selectionSetParam === 'string') {
        return parseSelectionSet(selectionSetParam);
    }
    if (isDocumentNode(selectionSetParam)) {
        return parseSelectionSet(print(selectionSetParam));
    }
    return selectionSetParam;
}
function normalizeSelectionSetParamOrFactory(selectionSetParamOrFactory) {
    return function getSelectionSet(subtree) {
        if (typeof selectionSetParamOrFactory === 'function') {
            const selectionSetParam = selectionSetParamOrFactory(subtree);
            return normalizeSelectionSetParam(selectionSetParam);
        }
        else {
            return normalizeSelectionSetParam(selectionSetParamOrFactory);
        }
    };
}
function identical(val) {
    return val;
}

export { getMesh };
