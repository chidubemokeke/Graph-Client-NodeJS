import { TypeInfo, ValidationContext, visitInParallel, visit, visitWithTypeInfo, GraphQLError, isListType, getNamedType, GraphQLInputObjectType, GraphQLNonNull } from 'graphql';
import { getArgumentValues } from '@graphql-tools/utils';

const symbolExtendedValidationRules = Symbol('extendedValidationContext');
const useExtendedValidation = (options) => {
    let schemaTypeInfo;
    function getTypeInfo() {
        return schemaTypeInfo;
    }
    return {
        onSchemaChange({ schema }) {
            schemaTypeInfo = new TypeInfo(schema);
        },
        onContextBuilding({ context, extendContext }) {
            // We initialize the validationRules context in onContextBuilding as onExecute is already too late!
            let validationRulesContext = context[symbolExtendedValidationRules];
            if (validationRulesContext === undefined) {
                validationRulesContext = {
                    rules: [],
                    didRun: false,
                };
                extendContext({
                    [symbolExtendedValidationRules]: validationRulesContext,
                });
            }
            validationRulesContext.rules.push(...options.rules);
        },
        onSubscribe: buildHandler('subscribe', getTypeInfo, options.onValidationFailed),
        onExecute: buildHandler('execute', getTypeInfo, options.onValidationFailed),
    };
};
function buildHandler(name, getTypeInfo, onValidationFailed) {
    return function handler({ args, setResultAndStopExecution, }) {
        var _a;
        // We hook into onExecute/onSubscribe even though this is a validation pattern. The reasoning behind
        // it is that hooking right after validation and before execution has started is the
        // same as hooking into the validation step. The benefit of this approach is that
        // we may use execution context in the validation rules.
        const validationRulesContext = args.contextValue[symbolExtendedValidationRules];
        if (validationRulesContext === undefined) {
            throw new Error('Plugin has not been properly set up. ' +
                `The 'contextFactory' function is not invoked and the result has not been passed to '${name}'.`);
        }
        // we only want to run the extended execution once.
        if (validationRulesContext.didRun === false) {
            validationRulesContext.didRun = true;
            if (validationRulesContext.rules.length !== 0) {
                const errors = [];
                // We replicate the default validation step manually before execution starts.
                const typeInfo = (_a = getTypeInfo()) !== null && _a !== void 0 ? _a : new TypeInfo(args.schema);
                const validationContext = new ValidationContext(args.schema, args.document, typeInfo, e => {
                    errors.push(e);
                });
                const visitor = visitInParallel(validationRulesContext.rules.map(rule => rule(validationContext, args)));
                visit(args.document, visitWithTypeInfo(typeInfo, visitor));
                if (errors.length > 0) {
                    let result = {
                        data: null,
                        errors,
                    };
                    if (onValidationFailed) {
                        onValidationFailed({ args, result, setResult: newResult => (result = newResult) });
                    }
                    setResultAndStopExecution(result);
                }
            }
        }
    };
}

function getDirectiveFromAstNode(astNode, names) {
    const directives = astNode.directives || [];
    const namesArr = Array.isArray(names) ? names : [names];
    const authDirective = directives.find(d => namesArr.includes(d.name.value));
    return authDirective || null;
}

const ONE_OF_DIRECTIVE_SDL = /* GraphQL */ `
  directive @oneOf on INPUT_OBJECT | FIELD_DEFINITION
`;
const OneOfInputObjectsRule = (validationContext, executionArgs) => {
    return {
        Field: node => {
            var _a, _b;
            if ((_a = node.arguments) === null || _a === void 0 ? void 0 : _a.length) {
                const fieldType = validationContext.getFieldDef();
                if (!fieldType) {
                    return;
                }
                const values = getArgumentValues(fieldType, node, executionArgs.variableValues || undefined);
                const isOneOfFieldType = ((_b = fieldType.extensions) === null || _b === void 0 ? void 0 : _b.oneOf) || (fieldType.astNode && getDirectiveFromAstNode(fieldType.astNode, 'oneOf'));
                if (isOneOfFieldType) {
                    if (Object.keys(values).length !== 1) {
                        validationContext.reportError(new GraphQLError(`Exactly one key must be specified for input for field "${fieldType.type.toString()}.${node.name.value}"`, [node]));
                    }
                }
                for (const arg of node.arguments) {
                    const argType = fieldType.args.find(typeArg => typeArg.name === arg.name.value);
                    if (argType) {
                        traverseVariables(validationContext, arg, argType.type, values[arg.name.value]);
                    }
                }
            }
        },
    };
};
function getNonNullType(ttype) {
    if (ttype instanceof GraphQLNonNull) {
        return ttype.ofType;
    }
    return ttype;
}
function traverseVariables(validationContext, arg, graphqlType, currentValue) {
    var _a;
    // if the current value is empty we don't need to traverse deeper
    // if it shouldn't be empty, the "original" validation phase should complain.
    if (currentValue == null) {
        return;
    }
    const unwrappedType = getNonNullType(graphqlType);
    if (isListType(unwrappedType)) {
        if (!Array.isArray(currentValue)) {
            // because of graphql type coercion a single object should be treated as an array of one object
            currentValue = [currentValue];
        }
        currentValue.forEach(value => {
            traverseVariables(validationContext, arg, unwrappedType.ofType, value);
        });
        return;
    }
    if (typeof currentValue !== 'object' || currentValue == null) {
        // in case the value is not an object, the "original" validation phase should complain.
        return;
    }
    const inputType = getNamedType(graphqlType);
    const isOneOfInputType = ((_a = inputType.extensions) === null || _a === void 0 ? void 0 : _a.oneOf) || (inputType.astNode && getDirectiveFromAstNode(inputType.astNode, 'oneOf'));
    if (isOneOfInputType) {
        if (Object.keys(currentValue).length !== 1) {
            validationContext.reportError(new GraphQLError(`Exactly one key must be specified for input type "${inputType.name}"`, [arg]));
        }
    }
    if (inputType instanceof GraphQLInputObjectType) {
        for (const [name, fieldConfig] of Object.entries(inputType.getFields())) {
            traverseVariables(validationContext, arg, fieldConfig.type, currentValue[name]);
        }
    }
}

export { ONE_OF_DIRECTIVE_SDL, OneOfInputObjectsRule, getDirectiveFromAstNode, useExtendedValidation };
